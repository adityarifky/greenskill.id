/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model. Users have complete control over their own data (`/users/{userId}`) and the training offers they create (`/training_offers/{trainingOfferId}`), but cannot see or interact with data belonging to other users.
 *
 * Data Structure: The data is organized into three distinct top-level collections:
 * 1. `/users/{userId}`: Stores private user profile information.
 * 2. `/registration_schemas/{registrationSchemaId}`: A collection of training schemas. Authenticated users can read and create them.
 * 3. `/training_offers/{trainingOfferId}`: A collection of user-specific training requests.
 *
 * Key Security Decisions:
 * - User data is strictly private. Access to any document under `/users/{userId}` is restricted to the authenticated user whose UID matches the document ID.
 * - User enumeration is disallowed. The rule `allow list: if false;` on the `/users` collection prevents any client from downloading a list of all users.
 * - Training Schemas (`/registration_schemas`) are readable by all authenticated users. Any authenticated user can create a new schema. Updates are restricted to owners (not yet fully implemented, but rule is in place for future use).
 * - Training Offers (`/training_offers`) are private to their creator. While stored in a global collection, each document contains a `userId` field that is used to enforce ownership for all reads and writes.
 *
 * Denormalization for Authorization: To ensure fast and secure access control, the `userId` is denormalized (copied) onto each `training_offers` document. This allows security rules to check for ownership directly on the document being requested, avoiding slow and costly `get()` calls to other parts of the database.
 *
 * Structural Segregation: Each primary data type (Users, Schemas, Offers) is stored in its own top-level collection. This separation simplifies security rules, as a single, consistent set of permissions can be applied to each collection without needing to inspect the content of individual documents.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user's UID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the requested document exists and if the user is the owner.
     * Used for safe update and delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null && resource.data.userId == userId;
    }

    /**
     * On create, validates that the user document's internal 'id' field
     * matches the document's ID in the path.
     */
    function userDocumentIsValidOnCreate(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * On update, ensures the user document's internal 'id' field is immutable.
     */
    function userDocumentIsImmutableOnUpdate() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * On create, validates that the new training offer's 'userId' field
     * matches the UID of the user creating it.
     */
    function trainingOfferIsValidOnCreate() {
      return request.resource.data.userId == request.auth.uid;
    }

    /**
     * On update, ensures the training offer's 'userId' field is immutable.
     */
    function trainingOfferIsImmutableOnUpdate() {
      return request.resource.data.userId == resource.data.userId;
    }

    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    /**
     * @description Controls access to user profile documents.
     * @path /users/{userId}
     * @allow (create, get, update, delete) An authenticated user can manage their own document.
     * @deny (list) Prevents any user from listing all user documents.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId} {
      allow get, update, delete: if isOwner(userId);
      allow create: if isOwner(userId) && userDocumentIsValidOnCreate(userId);
      allow list: if false; // Disallow listing all users for security
    }

    /**
     * @description Controls access to training schemas.
     * @path /registration_schemas/{registrationSchemaId}
     * @allow (get, list) Any authenticated user can read or list training schemas.
     * @allow (create) Any authenticated user can create a new schema.
     * @deny (update, delete) No client can update or delete from this collection directly (yet).
     * @principle Provides public read access and create access to authenticated users.
     */
    match /registration_schemas/{registrationSchemaId} {
      allow get, list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if false; 
      allow delete: if false;
    }

    /**
     * @description Controls access to private training offers created by users.
     * @path /training_offers/{trainingOfferId}
     * @allow (create, get, update, delete) An authenticated user can manage their own offers.
     * @deny (list) Prevents listing offers across different users directly from the client.
     * @principle Enforces document ownership for all reads and writes using a denormalized `userId` field.
     */
    match /training_offers/{trainingOfferId} {
      allow get, update, delete: if isExistingOwner(request.auth.uid);
      allow create: if isSignedIn() && trainingOfferIsValidOnCreate();
      allow list: if isSignedIn(); // Allow listing only for queries with a 'where' clause on userId
    }
  }
}
